(1) probar el hiding de las actions (what should be the impact?)

(2) Mostrar solo drops cuando no se hizo el deliver ni el drop, y se hizo el send correspondiente

(3) Dibujar mejor las flechas a self

(4) No crear drops cuando from == to (porque no hay red, asi que no se podrian perder)

(5) [Triggers]: "Every event triggered by a component of the same process is eventually processed, if the process is correct.
                Events from the same componet are processed in the order in which they were triggered. This FIFO order is
                only enforced on events exchanged among local components in a given stack.
                We assume that every process executes the code triggered by events in a mutually exclusive way. This means
                that the same process doen not handle two events concurrently." (Pag 10)
    Esto implica que no puedo hacer un bcast - send - (some other action) - send.
    Sin embargo, a nivel teoria de IOAutomata no encontre nada similar a un trigger, asi que por el momento lo voy a implementar como una capa por sobre la teoria: instalacion
    de tiggers en la execution).

(6) Deberia manerar dos conceptos de step
    - Sched index: unico por action.
    - Logical step: compartido por un grupo de acciones, por ejemplo los send de un bcast, o acciones concurrentes en distintos procesos.
                    Este seria util para mejorar los graficos.
    Habria que ver cual es el impacto en los filtros que estoy usando para mostrar solo las acciones disponibles en ese step.

(7) Revisar MessageID

(8) Con la implementación actual no puedo insertar lamport timestamp o vector clocks a los mensajes porque el numero de combinaciones tiende a infinito.
    Las acciones no solo van a depender de Sender + Receiver + Step + Payload, sino que dependen de la historia de mensajes enviados que es la que define el valor del vector clock.
    Por ahi para lamport timestamp no es tan dificil porque es un unico numero, podria generar para un Msg, la combinacion los timestamp de 1 a 1000, pero los vector clocks son mucho mas complejos.
    Alternativas
    (a) No usar lamport timestamps ni vector clocks. (X) Descartada: estas son las cosas mas interesantes en sistemas distribuidos.
    (b) No usar la teoria de IO. Me saca la base teorica.
    (c) No usar el payload como parte de las action que forman la signature del automata.
    (d) Agregar lamport timestamp como metadata de la action, de modo que no afecte la signature.

(9) Es muy complicado (y propenso a errores) reconocer que state corresponde a cual automata (tal vez para los que son de procesos no porque por ahora tengo 1 automata por proceso,
    por ejemplo 1 process y 1 bcast) pero si para los de links.

(10) Tengo que implementar un caso (o al menos una parte) con mi herramienta.
     Alternativas:
     - Cassandra
     - Kafka
     - CRDTs (tal vez con llevar, esto que no esta implementado en el libro, alcanza)

(11) Consultar a los autores del libro
     (a) abstracciones de links
          - UDP -> FairLossLink?
          - TCP -> PerfectLink?
     (b) cómo traducir los triggers?

(12) Shared memory.
     - Capacidad de dibujar writes and reads
     - "Remember that these events occur at a single indivisible point in time, using a fictional notion of global time that only serves to reason about specifitacions and algorithms" (pag 141)
       ¿Se refiere al par de ventos Read-ReadReturn y Write-WriteReturn?
     - "An operation o is said to precede an operation o' if the completion event of o occurs BEFORE the invocation event of o'" (pag 141)
       ¿Before según qué? ¿Puedo usar el orden de la action en la execution para definir before?, el problema es que no podría considerar actions concurrentes.
       La otra opción sería la de usar el step en lugar del índice de la action en la execution, es decir el step lógico que usaría para seleccionar un conjunto de acciones (1 por process).
       Funcionaría como un reloj lógico. Aunque también debería incorporar el uso de un reloj físico porque me va a permitr usar drift y skew (el lógico no).

(13) "The instances are differentiated by their identifiers, and all messages exchanged using the underlying communication primitives
      implicitly carry an instance identifier to match the same instance at all processes" (pag 145)

(14) Deliver a un processo Down deberia estar habilitado, y que no haga nada.

(15) Incorporar interfaces = Name + Requests (aka input actions) + Indications (aka output actions) + Properties
     Las properties no van a tener un impacto directo (a menos que sepa traducirlas a condiciones sobre la execution, lo que estaria muy bueno)
     Investigar cual seria el impacto concreto

(16) Como dibujar stacks de componentes?
     En la teoria de automatas no está, tal vez debería definirla paralelamente al automata (o implementar la lógica basada en las input y output actions, ejemplo
     si un componente A tiene como output action la input action de un componente B, A esta en layer n y B en layer n + 1)

(17) Reemplazar pattern matching del estilo `id` por el chequeo de si esta en la input action (que va a ser universal para todos los automatons)

(18) Tengo que introducir algunas constraints definidas por el System Model.
     Puntualmente cuando se trata de sync model "the transmission period of every message is bounded by some known constant" (pag 50)
     Por lo tanto el usuario no puede elegir demorar el Deliver tod el tiempo que quiara, esto es fundamental para PerfectFailureDetector.

(19) Una instancia de FairLossLink,
     hace send de A a B
     y hace deliver de B a A?, o deliver de A a B?

(20) Estoy manejando dos tipos de estados en los automatas
     (a) Visible: es propio de la abstraction implementada. Ejemplo alive and detected sets on PerfectFailureDetection.
     (b) Interno: este es el que uso para implementar los triggers (enabled "actions" like deliver after a send). Este estado no se debería mostrar hacia afuera, y no es de interes para el usuario.

(21) Triggers is broken!!!
     No puedo calcular las actions to trigger solo a partir de la input action en tods los casos (como BrkDeliver a partir de Deliver).
     Ejemplo: PerfectFailureDetector, on Timeout trigger Crash solo para un subconjunto de procesos.
     Alternativas
     (a) type Triggers = PartialFunction[(Action,S), Set[Action]] (donde S es el State) (ver si es viable)
     (b) trait Steps[S] extends PartialFunction[(S, Action), NextState[S]]

(22) Effect.precondition should return more information than a boolean, for debuggin purposes.

(23) Facilitar lo que es pattern matching de output actions. Tener un State[S](triggered: Set[Action], s: S) y el pattern matching solo se fije si esta en el set triggered

(24) Revisar el uso de Step. ¿Para que lo necesito? ====> Step lo uso para armar el MessageID y que cada msg sea unico.

(25) Revisar el uso de Message, porque mandar un payload directamente? Esta relacionado con el punto 24 porque Message tmb incluye un MessageID.
     El uso de MessageID era para identificar univocamente los mensajes y poder armar la signature en base a estos mensajes. También podria usar un UUID pero en ese caso, cuantos uuid armo?

(26) Internal Actions. Timeout (PerfectFailureDetector)
     No puede estar siempre disponible.
      (a) Creo acciones de tipo Timeout(step = 0), Timeout(step = 3), Timeout(step = 6) (Donde 3 seria el bounded delay del synchronous system).
      (b) La habilito en base al estado. Este estado deberia tener algun Clock que identifique el step, que se actualice con una input action Tick.

(27) Como implementar el synchronous system, que a comparacion del partially synchronous tiene un bounded delay y me permite usar algoritmos como el de PerfectFailureDetector?

(28) Tests!!!!!

(29) Steps[S] extends PartialFunction[(S, Action), ActionResult[S]]
     Donde ActionResult = NextState | NotDefined | UnsatisfiedPrecondition
